\documentclass[a4paper,12pt]{article}

\usepackage[hidelinks]{hyperref}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{shorttoc}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{{./img/}}

\definecolor{linkcolor}{HTML}{000000}
\definecolor{urlcolor}{HTML}{0085FF}
\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}

\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\renewcommand*\contentsname{Содержание}

\newcommand{\plot}[4]{
    \begin{figure}[H]
        \begin{center}
            \includegraphics[scale=#4]{#1}
            \caption{#2}
            \label{#3}
        \end{center}
    \end{figure}
}

\begin{document}
    \include{title}
    \newpage

    \tableofcontents
    \newpage

    \section{Постановка задачи}
    \quad Необходимо разработать алгоритм для решения задачи византийских генералов.

    \section{Теория}
    \quad Существует группа из $ n $ генералов, среди которых $ m $ являются предателями. Каждый из этих $ n $ генералов обладает надежным каналом связи, который исключает возможность подмены сообщений. Все лояльные генералы, их количество составляет $ n - m $, всегда отправляют правдивые и неизменные сообщения. В то же время, каждый из $ m $ предателей отправляет неправдивые и потенциально изменяемые сообщения. Задача лояльных генералов заключается в идентификации предателей посредством обмена сообщениями.

    Рассмотрим решение этой проблемы в специфическом случае, когда количество предателей остается постоянным и $ n > 3m $.
    Для такой ситуации применим алгоритм Лампорта, который включает в себя определенные этапы.
    \begin{itemize}
        \item Каждый из генералов отправляет сообщение всем остальным: верные генералы отправляют правдивое сообщение, а предатели – неправдивое.
        \item В результате, у каждого генерала образуется массив из $ n $ элементов, который включает полученные сообщения и собственное.
        \item После этого каждый генерал пересылает остальным сформированный массив, полученный на предыдущем этапе.
        \item В финальной стадии каждый генерал имеет серию векторов: свой собственный и те, что были получены от других генералов. Для каждого $ i $-го элемента в этих векторах определяется наиболее часто встречающееся значение. Если оно встречается как минимум $ n - m $ раз, его считают истинным и включают в итоговый вектор, в противном случае в итоговый вектор добавляется ноль.
    \end{itemize}

    Таким образом, все верные генералы в итоге получают идентичный набор значений.

    \section{Реализация}
    \quad Весь код написан на языке Python (версии 3.9).
    Каждый генерал работает в отдельном потоке. Предполагается, что отправленное сообщение не может быть потерянно.
    \href{https://github.com/gobdr/Networks/tree/master/3_lab}{Ссылка на GitHub с исходным кодом}.

    \section{Результаты}
    Для демонстрации работы алгоритма используем пример, где общее количество генералов составляет $ n = 9 $, среди которых $ m = 2 $ являются предателями. Верные генералы отправляют сообщения, содержащие их порядковые номера (индексы), в то время как предатели отправляют сообщения формата tr\_$ i $, где $ i $ — порядковый номер генерала-предателя. Предателями являются генералы под номерами $ 7 $ и $ 8 $.

    В ходе первых двух этапов работы алгоритма каждый генерал получает следующий вектор значений.
    \plot{gen1}{Сформированные векторы у каждого генерала}{p:gen1}{0.6}

    На следующем этапе каждый верный генерал отправляет ранее сформированный им вектор другим генералам. Предатель же, посылая сообщения, вносит изменения в свой вектор: к каждому элементу добавляется фраза tr\_$ i $, где $ i $ обозначает порядковый номер генерала, которому отправляется сообщение.

    В результате этого шага у каждого генерала складывается собственный набор векторов. Для наглядности рассмотрим по одному примеру вектора, полученного верным генералом и предателем.
    \plot{gen2}{Сформированный набор векторов для верного генерала (индекс $ 0 $) и предателя ($ 1 $)}{p:gen2}{0.5}

    После завершения всех этапов алгоритма, каждый генерал формирует результирующий вектор. В этом векторе элемент None обозначает генерала-предателя.

    Таким образом, результирующий вектор каждого генерала содержит либо порядковые номера верных генералов, либо None на месте предателей.
    \plot{gen3}{Итоговый набор у каждого генерала}{p:gen3}{0.6}
 
    Как видно, в сценарии, когда все генералы сформировали одинаковый итоговый вектор, это означает, что они пришли к согласию и успешно определили предателей. Это демонстрирует эффективность алгоритма в случае, когда $ n > 3m $.

    Теперь рассмотрим ситуацию, когда $ n \leq 3m $. Возьмем для примера $ n = 5 $ и $ m = 2 $. В этом случае, после завершения всех шагов алгоритма, каждый генерал сформировал следующий итоговый вектор:

    \plot{genf}{Итоговый набор у каждого генерала в случае $ n \leq 3m $}{p:genf}{0.6}

    Как видно на рисунке $ \ref{p:genf} $, верные генералы не смогли прийти к согласию.
    Это указывает на ограничения алгоритма в условиях, когда число предателей сопоставимо или превышает одну треть от общего числа генералов.

    \section{Заключение}
    Из представленных результатов становится очевидно, что когда условие $ n \leq 3m $ выполняется, существует риск того, что генералы не смогут достичь консенсуса. Это связано с тем, что в таких ситуациях влияние предателей становится слишком значительным, что мешает достижению единого мнения среди верных генералов.

    В то же время, в случаях, когда $ n > 3m $, алгоритм обеспечивает гарантию того, что согласие всегда может быть достигнуто. Это происходит благодаря тому, что количество верных генералов достаточно велико по сравнению с количеством предателей, что позволяет надежно идентифицировать ложные сообщения и достигать единого решения.

\end{document}